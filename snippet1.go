// -*- mode:go;mode:go-playground -*-
// snippet of code @ 2018-07-29 04:31:04

// === Go Playground ===
// Execute the snippet with Ctl-Return
// Remove the snippet completely with its dir and all files M-x `go-playground-rm`

package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"strconv"
	"strings"
)

type PlayerServ struct {
	List map[string]*Player
}

func (ps *PlayerServ) String() string {
	s := ""
	for key, val := range ps.List {
		s += fmt.Sprintf("%s: %s\n", key, val)
	}
	s = strings.TrimRight(s, "\n")
	return s
}

func (p *Player) String() string {
	return fmt.Sprintf("name:'%s', health:%d", p.Name, p.Health)
}

// --------------------------------
// todo:

// 1. The Function Table.
// 
// create a function table where you can define the functions that you
// want to expose to the outside world, and any additional information
// that may be useful: such as "blocking vs. nonblocking", or
// "requires login", etc.
//
// One possibility would be to analyze the Go source code and use the
// exposed functions automatically.  Additional information could be
// passed to the code generator through comments (which I THINK is the
// way its done).  This might be easier and cleaner overall.
//
// However...  Using an interface would prevent the need for code
// generation each time the package is changed.  Any type could add
// some functions like...  FunctionMap() and have it satisfy the
// interface.  Then, the program (containing the interface definition)
// could invoke FunctionMap() to find out all the information it needs
// about the functions!
//
// The functionmap could even contain a pointer to the function, which
// would allow it to be invoked more easily, without as much need for
// the reflect package.




// 2. The Grammar Link.
//
// It is likely that the grammar will change frequently.  Probably
// best to generate the parser using a tool like LEX or goYACC.  or
// just build something yourself.
//
// The grammar must be decoupled from the function table and from the
// service, UNLIKE THIS EXAMPLE.
//
// The service should just be a regular old package, with regular old
// functions, perahps with some additional information for the
// generator included. (But it shouldn't be required.)


// --------------------------------
// 
// THE handler function will later be automatically generated.  This
// is the generic reader/writer interface function which will
// encapsulate the automata.
//
// In this example, it scans by line, but that may not be the case for
// all grammars.  For example, it may scan by newline or a semicolon,
// or it may read in the entire message at once.
//
func (ps *PlayerServ) handle(in io.Reader, out io.Writer) {
	input := bufio.NewScanner(in)
	for input.Scan() {
		ans, err := ps.command(input.Text())
		if err != nil {
			fmt.Fprintln(out, err)
			continue
		}
		fmt.Fprintln(out, ans)
	}
}

// error messages will be mostly common things like "wrong number of
// parameters" or "function f does not exist" or "type mismatch int
// vs. string".
//
// They will also be autogenerated, but are part of the "bootstrap",
// and will be mostly a function that returns a useful error. Example:
// errParameters(name, x, y) would print an error like "function
// <name> expects <x> parameters, got <y> instead".
//
var (
	errEmpty   = fmt.Errorf("emtpy line")
	errCommand = fmt.Errorf("unknown command")
	errAttr    = fmt.Errorf("unknown player attribute")
	errPlayer  = fmt.Errorf("unknown player")
)

func (ps *PlayerServ) command(s string) (string, error) {
	args := strings.Split(s, " ")
	nArgs := len(args)
	if nArgs <= 0 {
		return "", errEmpty
	}
	cmd := args[0]

	switch cmd {
	case "list":
		if nArgs != 1 {
			return "", fmt.Errorf("'list' expects no parameters.")
		}
		return fmt.Sprint(ps), nil

	case "get":
		if nArgs != 2 {
			return "", fmt.Errorf("'get' expects 1 parameters.")
		}
		return ps.get(args[1])

	case "set":
		if nArgs != 4 {
			return "", fmt.Errorf("'set' expects 3 parameters.")
		}
		return ps.set(args[1], args[2], args[3])

	default:
		return "", errCommand
	}
}

func (ps *PlayerServ) set(name, field, val string) (string, error) {
	person, ok := ps.List[name]
	if !ok {
		return "", errPlayer
	}
	switch field {
	case "name":
		person.Name = val
		return "done.", nil

	case "hp", "health":
		newhp, err := strconv.Atoi(val)
		if err != nil {
			return "", fmt.Errorf("health must be an integer.")
		}
		person.Health = newhp
		return "done.", nil

	default:
		return "", errAttr
	}

}

func (ps *PlayerServ) get(name string) (string, error) {
	person, ok := ps.List[name]
	if !ok {
		return "", errPlayer
	}
	return fmt.Sprint(person), nil
}

type Player struct {
	Name   string
	Health int
}

var exList = map[string]*Player{
	"p1": &Player{"me", 123},
	"p2": &Player{"you", 343},
}

var example = &PlayerServ{exList}

func main() {
	fmt.Println("Results:")
	example.handle(os.Stdin, os.Stdout)
}
